(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors-dashboard-explore-welcome"],{

/***/ "./node_modules/rison/js/rison.js":
/*!****************************************!*\
  !*** ./node_modules/rison/js/rison.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Uses CommonJS, AMD or browser globals to create a module.\n// Based on: https://github.com/umdjs/umd/blob/master/commonjsStrict.js\n(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function (exports) {\nvar rison = exports;\n\n//////////////////////////////////////////////////\n//\n//  the stringifier is based on\n//    http://json.org/json.js as of 2006-04-28 from json.org\n//  the parser is based on \n//    http://osteele.com/sources/openlaszlo/json\n//\n\nif (typeof rison == 'undefined')\n    window.rison = {};\n\n/**\n *  rules for an uri encoder that is more tolerant than encodeURIComponent\n *\n *  encodeURIComponent passes  ~!*()-_.'\n *\n *  we also allow              ,:@$/\n *\n */\nrison.uri_ok = {  // ok in url paths and in form query args\n            '~': true,  '!': true,  '*': true,  '(': true,  ')': true,\n            '-': true,  '_': true,  '.': true,  ',': true,\n            ':': true,  '@': true,  '$': true,\n            \"'\": true,  '/': true\n};\n\n/*\n * we divide the uri-safe glyphs into three sets\n *   <rison> - used by rison                         ' ! : ( ) ,\n *   <reserved> - not common in strings, reserved    * @ $ & ; =\n *\n * we define <identifier> as anything that's not forbidden\n */\n\n/**\n * punctuation characters that are legal inside ids.\n */\n// this var isn't actually used\n//rison.idchar_punctuation = \"_-./~\";  \n\n(function () {\n    var l = [];\n    for (var hi = 0; hi < 16; hi++) {\n        for (var lo = 0; lo < 16; lo++) {\n            if (hi+lo == 0) continue;\n            var c = String.fromCharCode(hi*16 + lo);\n            if (! /\\w|[-_.\\/~]/.test(c))\n                l.push('\\\\u00' + hi.toString(16) + lo.toString(16));\n        }\n    }\n    /**\n     * characters that are illegal inside ids.\n     * <rison> and <reserved> classes are illegal in ids.\n     *\n     */\n    rison.not_idchar = l.join('')\n    //idcrx = new RegExp('[' + rison.not_idchar + ']');\n    //console.log('NOT', (idcrx.test(' ')) );\n})();\n//rison.not_idchar  = \" \\t\\r\\n\\\"<>[]{}'!=:(),*@$;&\";\nrison.not_idchar  = \" '!:(),*@$\";\n\n\n/**\n * characters that are illegal as the start of an id\n * this is so ids can't look like numbers.\n */\nrison.not_idstart = \"-0123456789\";\n\n\n(function () {\n    var idrx = '[^' + rison.not_idstart + rison.not_idchar + \n               '][^' + rison.not_idchar + ']*';\n\n    rison.id_ok = new RegExp('^' + idrx + '$');\n\n    // regexp to find the end of an id when parsing\n    // g flag on the regexp is necessary for iterative regexp.exec()\n    rison.next_id = new RegExp(idrx, 'g');\n})();\n\n/**\n * this is like encodeURIComponent() but quotes fewer characters.\n *\n * @see rison.uri_ok\n *\n * encodeURIComponent passes   ~!*()-_.'\n * rison.quote also passes   ,:@$/\n *   and quotes \" \" as \"+\" instead of \"%20\"\n */\nrison.quote = function(x) {\n    if (/^[-A-Za-z0-9~!*()_.',:@$\\/]*$/.test(x))\n        return x;\n\n    return encodeURIComponent(x)\n        .replace('%2C', ',', 'g')\n        .replace('%3A', ':', 'g')\n        .replace('%40', '@', 'g')\n        .replace('%24', '$', 'g')\n        .replace('%2F', '/', 'g')\n        .replace('%20', '+', 'g');\n};\n\n\n//\n//  based on json.js 2006-04-28 from json.org\n//  license: http://www.json.org/license.html\n//\n//  hacked by nix for use in uris.\n//\n\n(function () {\n    var sq = { // url-ok but quoted in strings\n               \"'\": true,  '!': true\n    },\n    s = {\n            array: function (x) {\n                var a = ['!('], b, f, i, l = x.length, v;\n                for (i = 0; i < l; i += 1) {\n                    v = x[i];\n                    f = s[typeof v];\n                    if (f) {\n                        v = f(v);\n                        if (typeof v == 'string') {\n                            if (b) {\n                                a[a.length] = ',';\n                            }\n                            a[a.length] = v;\n                            b = true;\n                        }\n                    }\n                }\n                a[a.length] = ')';\n                return a.join('');\n            },\n            'boolean': function (x) {\n                if (x)\n                    return '!t';\n                return '!f'\n            },\n            'null': function (x) {\n                return \"!n\";\n            },\n            number: function (x) {\n                if (!isFinite(x))\n                    return '!n';\n                // strip '+' out of exponent, '-' is ok though\n                return String(x).replace(/\\+/,'');\n            },\n            object: function (x) {\n                if (x) {\n                    if (x instanceof Array) {\n                        return s.array(x);\n                    }\n                    // WILL: will this work on non-Firefox browsers?\n                    if (typeof x.__prototype__ === 'object' && typeof x.__prototype__.encode_rison !== 'undefined')\n                        return x.encode_rison();\n\n                    var a = ['('], b, f, i, v, ki, ks=[];\n                    for (i in x)\n                        ks[ks.length] = i;\n                    ks.sort();\n                    for (ki = 0; ki < ks.length; ki++) {\n                        i = ks[ki];\n                        v = x[i];\n                        f = s[typeof v];\n                        if (f) {\n                            v = f(v);\n                            if (typeof v == 'string') {\n                                if (b) {\n                                    a[a.length] = ',';\n                                }\n                                a.push(s.string(i), ':', v);\n                                b = true;\n                            }\n                        }\n                    }\n                    a[a.length] = ')';\n                    return a.join('');\n                }\n                return '!n';\n            },\n            string: function (x) {\n                if (x == '')\n                    return \"''\";\n\n                if (rison.id_ok.test(x))\n                    return x;\n\n                x = x.replace(/(['!])/g, function(a, b) {\n                    if (sq[b]) return '!'+b;\n                    return b;\n                });\n                return \"'\" + x + \"'\";\n            },\n            undefined: function (x) {\n                throw new Error(\"rison can't encode the undefined value\");\n            }\n        };\n\n\n    /**\n     * rison-encode a javascript structure\n     *\n     *  implemementation based on Douglas Crockford's json.js:\n     *    http://json.org/json.js as of 2006-04-28 from json.org\n     *\n     */\n    rison.encode = function (v) {\n        return s[typeof v](v);\n    };\n\n    /**\n     * rison-encode a javascript object without surrounding parens\n     *\n     */\n    rison.encode_object = function (v) {\n        if (typeof v != 'object' || v === null || v instanceof Array)\n            throw new Error(\"rison.encode_object expects an object argument\");\n        var r = s[typeof v](v);\n        return r.substring(1, r.length-1);\n    };\n\n    /**\n     * rison-encode a javascript array without surrounding parens\n     *\n     */\n    rison.encode_array = function (v) {\n        if (!(v instanceof Array))\n            throw new Error(\"rison.encode_array expects an array argument\");\n        var r = s[typeof v](v);\n        return r.substring(2, r.length-1);\n    };\n\n    /**\n     * rison-encode and uri-encode a javascript structure\n     *\n     */\n    rison.encode_uri = function (v) {\n        return rison.quote(s[typeof v](v));\n    };\n\n})();\n\n\n\n\n//\n// based on openlaszlo-json and hacked by nix for use in uris.\n//\n// Author: Oliver Steele\n// Copyright: Copyright 2006 Oliver Steele.  All rights reserved.\n// Homepage: http://osteele.com/sources/openlaszlo/json\n// License: MIT License.\n// Version: 1.0\n\n\n/**\n * parse a rison string into a javascript structure.\n *\n * this is the simplest decoder entry point.\n *\n *  based on Oliver Steele's OpenLaszlo-JSON\n *     http://osteele.com/sources/openlaszlo/json\n */\nrison.decode = function(r) {\n    var errcb = function(e) { throw Error('rison decoder error: ' + e); };\n    var p = new rison.parser(errcb);\n    return p.parse(r);\n};\n\n/**\n * parse an o-rison string into a javascript structure.\n *\n * this simply adds parentheses around the string before parsing.\n */\nrison.decode_object = function(r) {\n    return rison.decode('('+r+')');\n};\n\n/**\n * parse an a-rison string into a javascript structure.\n *\n * this simply adds array markup around the string before parsing.\n */\nrison.decode_array = function(r) {\n    return rison.decode('!('+r+')');\n};\n\n\n/**\n * construct a new parser object for reuse.\n *\n * @constructor\n * @class A Rison parser class.  You should probably \n *        use rison.decode instead. \n * @see rison.decode\n */\nrison.parser = function (errcb) {\n    this.errorHandler = errcb;\n};\n\n/**\n * a string containing acceptable whitespace characters.\n * by default the rison decoder tolerates no whitespace.\n * to accept whitespace set rison.parser.WHITESPACE = \" \\t\\n\\r\\f\";\n */\nrison.parser.WHITESPACE = \"\";\n\n// expose this as-is?\nrison.parser.prototype.setOptions = function (options) {\n    if (options['errorHandler'])\n        this.errorHandler = options.errorHandler;\n};\n\n/**\n * parse a rison string into a javascript structure.\n */\nrison.parser.prototype.parse = function (str) {\n    this.string = str;\n    this.index = 0;\n    this.message = null;\n    var value = this.readValue();\n    if (!this.message && this.next())\n        value = this.error(\"unable to parse string as rison: '\" + rison.encode(str) + \"'\");\n    if (this.message && this.errorHandler)\n        this.errorHandler(this.message, this.index);\n    return value;\n};\n\nrison.parser.prototype.error = function (message) {\n    if (typeof(console) != 'undefined')\n        console.log('rison parser error: ', message);\n    this.message = message;\n    return undefined;\n}\n    \nrison.parser.prototype.readValue = function () {\n    var c = this.next();\n    var fn = c && this.table[c];\n\n    if (fn)\n        return fn.apply(this);\n\n    // fell through table, parse as an id\n\n    var s = this.string;\n    var i = this.index-1;\n\n    // Regexp.lastIndex may not work right in IE before 5.5?\n    // g flag on the regexp is also necessary\n    rison.next_id.lastIndex = i;\n    var m = rison.next_id.exec(s);\n\n    // console.log('matched id', i, r.lastIndex);\n\n    if (m.length > 0) {\n        var id = m[0];\n        this.index = i+id.length;\n        return id;  // a string\n    }\n\n    if (c) return this.error(\"invalid character: '\" + c + \"'\");\n    return this.error(\"empty expression\");\n}\n\nrison.parser.parse_array = function (parser) {\n    var ar = [];\n    var c;\n    while ((c = parser.next()) != ')') {\n        if (!c) return parser.error(\"unmatched '!('\");\n        if (ar.length) {\n            if (c != ',')\n                parser.error(\"missing ','\");\n        } else if (c == ',') {\n            return parser.error(\"extra ','\");\n        } else\n            --parser.index;\n        var n = parser.readValue();\n        if (typeof n == \"undefined\") return undefined;\n        ar.push(n);\n    }\n    return ar;\n};\n\nrison.parser.bangs = {\n    t: true,\n    f: false,\n    n: null,\n    '(': rison.parser.parse_array\n}\n\nrison.parser.prototype.table = {\n    '!': function () {\n        var s = this.string;\n        var c = s.charAt(this.index++);\n        if (!c) return this.error('\"!\" at end of input');\n        var x = rison.parser.bangs[c];\n        if (typeof(x) == 'function') {\n            return x.call(null, this);\n        } else if (typeof(x) == 'undefined') {\n            return this.error('unknown literal: \"!' + c + '\"');\n        }\n        return x;\n    },\n    '(': function () {\n        var o = {};\n        var c;\n        var count = 0;\n        while ((c = this.next()) != ')') {\n            if (count) {\n                if (c != ',')\n                    this.error(\"missing ','\");\n            } else if (c == ',') {\n                return this.error(\"extra ','\");\n            } else\n                --this.index;\n            var k = this.readValue();\n            if (typeof k == \"undefined\") return undefined;\n            if (this.next() != ':') return this.error(\"missing ':'\");\n            var v = this.readValue();\n            if (typeof v == \"undefined\") return undefined;\n            o[k] = v;\n            count++;\n        }\n        return o;\n    },\n    \"'\": function () {\n        var s = this.string;\n        var i = this.index;\n        var start = i;\n        var segments = [];\n        var c;\n        while ((c = s.charAt(i++)) != \"'\") {\n            //if (i == s.length) return this.error('unmatched \"\\'\"');\n            if (!c) return this.error('unmatched \"\\'\"');\n            if (c == '!') {\n                if (start < i-1)\n                    segments.push(s.slice(start, i-1));\n                c = s.charAt(i++);\n                if (\"!'\".indexOf(c) >= 0) {\n                    segments.push(c);\n                } else {\n                    return this.error('invalid string escape: \"!'+c+'\"');\n                }\n                start = i;\n            }\n        }\n        if (start < i-1)\n            segments.push(s.slice(start, i-1));\n        this.index = i;\n        return segments.length == 1 ? segments[0] : segments.join('');\n    },\n    // Also any digit.  The statement that follows this table\n    // definition fills in the digits.\n    '-': function () {\n        var s = this.string;\n        var i = this.index;\n        var start = i-1;\n        var state = 'int';\n        var permittedSigns = '-';\n        var transitions = {\n            'int+.': 'frac',\n            'int+e': 'exp',\n            'frac+e': 'exp'\n        };\n        do {\n            var c = s.charAt(i++);\n            if (!c) break;\n            if ('0' <= c && c <= '9') continue;\n            if (permittedSigns.indexOf(c) >= 0) {\n                permittedSigns = '';\n                continue;\n            }\n            state = transitions[state+'+'+c.toLowerCase()];\n            if (state == 'exp') permittedSigns = '-';\n        } while (state);\n        this.index = --i;\n        s = s.slice(start, i)\n        if (s == '-') return this.error(\"invalid number\");\n        return Number(s);\n    }\n};\n// copy table['-'] to each of table[i] | i <- '0'..'9':\n(function (table) {\n    for (var i = 0; i <= 9; i++)\n        table[String(i)] = table['-'];\n})(rison.parser.prototype.table);\n\n// return the next non-whitespace character, or undefined\nrison.parser.prototype.next = function () {\n    var s = this.string;\n    var i = this.index;\n    do {\n        if (i == s.length) return undefined;\n        var c = s.charAt(i++);\n    } while (rison.parser.WHITESPACE.indexOf(c) >= 0);\n    this.index = i;\n    return c;\n};\n\n// End of UMD module wrapper\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmlzb24vanMvcmlzb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlzb24vanMvcmlzb24uanM/NGM0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVc2VzIENvbW1vbkpTLCBBTUQgb3IgYnJvd3NlciBnbG9iYWxzIHRvIGNyZWF0ZSBhIG1vZHVsZS5cbi8vIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL2NvbW1vbmpzU3RyaWN0LmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb21tb25KU1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICBmYWN0b3J5KChyb290LnJpc29uID0ge30pKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG52YXIgcmlzb24gPSBleHBvcnRzO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICB0aGUgc3RyaW5naWZpZXIgaXMgYmFzZWQgb25cbi8vICAgIGh0dHA6Ly9qc29uLm9yZy9qc29uLmpzIGFzIG9mIDIwMDYtMDQtMjggZnJvbSBqc29uLm9yZ1xuLy8gIHRoZSBwYXJzZXIgaXMgYmFzZWQgb24gXG4vLyAgICBodHRwOi8vb3N0ZWVsZS5jb20vc291cmNlcy9vcGVubGFzemxvL2pzb25cbi8vXG5cbmlmICh0eXBlb2Ygcmlzb24gPT0gJ3VuZGVmaW5lZCcpXG4gICAgd2luZG93LnJpc29uID0ge307XG5cbi8qKlxuICogIHJ1bGVzIGZvciBhbiB1cmkgZW5jb2RlciB0aGF0IGlzIG1vcmUgdG9sZXJhbnQgdGhhbiBlbmNvZGVVUklDb21wb25lbnRcbiAqXG4gKiAgZW5jb2RlVVJJQ29tcG9uZW50IHBhc3NlcyAgfiEqKCktXy4nXG4gKlxuICogIHdlIGFsc28gYWxsb3cgICAgICAgICAgICAgICw6QCQvXG4gKlxuICovXG5yaXNvbi51cmlfb2sgPSB7ICAvLyBvayBpbiB1cmwgcGF0aHMgYW5kIGluIGZvcm0gcXVlcnkgYXJnc1xuICAgICAgICAgICAgJ34nOiB0cnVlLCAgJyEnOiB0cnVlLCAgJyonOiB0cnVlLCAgJygnOiB0cnVlLCAgJyknOiB0cnVlLFxuICAgICAgICAgICAgJy0nOiB0cnVlLCAgJ18nOiB0cnVlLCAgJy4nOiB0cnVlLCAgJywnOiB0cnVlLFxuICAgICAgICAgICAgJzonOiB0cnVlLCAgJ0AnOiB0cnVlLCAgJyQnOiB0cnVlLFxuICAgICAgICAgICAgXCInXCI6IHRydWUsICAnLyc6IHRydWVcbn07XG5cbi8qXG4gKiB3ZSBkaXZpZGUgdGhlIHVyaS1zYWZlIGdseXBocyBpbnRvIHRocmVlIHNldHNcbiAqICAgPHJpc29uPiAtIHVzZWQgYnkgcmlzb24gICAgICAgICAgICAgICAgICAgICAgICAgJyAhIDogKCApICxcbiAqICAgPHJlc2VydmVkPiAtIG5vdCBjb21tb24gaW4gc3RyaW5ncywgcmVzZXJ2ZWQgICAgKiBAICQgJiA7ID1cbiAqXG4gKiB3ZSBkZWZpbmUgPGlkZW50aWZpZXI+IGFzIGFueXRoaW5nIHRoYXQncyBub3QgZm9yYmlkZGVuXG4gKi9cblxuLyoqXG4gKiBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzIHRoYXQgYXJlIGxlZ2FsIGluc2lkZSBpZHMuXG4gKi9cbi8vIHRoaXMgdmFyIGlzbid0IGFjdHVhbGx5IHVzZWRcbi8vcmlzb24uaWRjaGFyX3B1bmN0dWF0aW9uID0gXCJfLS4vflwiOyAgXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGwgPSBbXTtcbiAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgMTY7IGhpKyspIHtcbiAgICAgICAgZm9yICh2YXIgbG8gPSAwOyBsbyA8IDE2OyBsbysrKSB7XG4gICAgICAgICAgICBpZiAoaGkrbG8gPT0gMCkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaGkqMTYgKyBsbyk7XG4gICAgICAgICAgICBpZiAoISAvXFx3fFstXy5cXC9+XS8udGVzdChjKSlcbiAgICAgICAgICAgICAgICBsLnB1c2goJ1xcXFx1MDAnICsgaGkudG9TdHJpbmcoMTYpICsgbG8udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGFyYWN0ZXJzIHRoYXQgYXJlIGlsbGVnYWwgaW5zaWRlIGlkcy5cbiAgICAgKiA8cmlzb24+IGFuZCA8cmVzZXJ2ZWQ+IGNsYXNzZXMgYXJlIGlsbGVnYWwgaW4gaWRzLlxuICAgICAqXG4gICAgICovXG4gICAgcmlzb24ubm90X2lkY2hhciA9IGwuam9pbignJylcbiAgICAvL2lkY3J4ID0gbmV3IFJlZ0V4cCgnWycgKyByaXNvbi5ub3RfaWRjaGFyICsgJ10nKTtcbiAgICAvL2NvbnNvbGUubG9nKCdOT1QnLCAoaWRjcngudGVzdCgnICcpKSApO1xufSkoKTtcbi8vcmlzb24ubm90X2lkY2hhciAgPSBcIiBcXHRcXHJcXG5cXFwiPD5bXXt9JyE9OigpLCpAJDsmXCI7XG5yaXNvbi5ub3RfaWRjaGFyICA9IFwiICchOigpLCpAJFwiO1xuXG5cbi8qKlxuICogY2hhcmFjdGVycyB0aGF0IGFyZSBpbGxlZ2FsIGFzIHRoZSBzdGFydCBvZiBhbiBpZFxuICogdGhpcyBpcyBzbyBpZHMgY2FuJ3QgbG9vayBsaWtlIG51bWJlcnMuXG4gKi9cbnJpc29uLm5vdF9pZHN0YXJ0ID0gXCItMDEyMzQ1Njc4OVwiO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkcnggPSAnW14nICsgcmlzb24ubm90X2lkc3RhcnQgKyByaXNvbi5ub3RfaWRjaGFyICsgXG4gICAgICAgICAgICAgICAnXVteJyArIHJpc29uLm5vdF9pZGNoYXIgKyAnXSonO1xuXG4gICAgcmlzb24uaWRfb2sgPSBuZXcgUmVnRXhwKCdeJyArIGlkcnggKyAnJCcpO1xuXG4gICAgLy8gcmVnZXhwIHRvIGZpbmQgdGhlIGVuZCBvZiBhbiBpZCB3aGVuIHBhcnNpbmdcbiAgICAvLyBnIGZsYWcgb24gdGhlIHJlZ2V4cCBpcyBuZWNlc3NhcnkgZm9yIGl0ZXJhdGl2ZSByZWdleHAuZXhlYygpXG4gICAgcmlzb24ubmV4dF9pZCA9IG5ldyBSZWdFeHAoaWRyeCwgJ2cnKTtcbn0pKCk7XG5cbi8qKlxuICogdGhpcyBpcyBsaWtlIGVuY29kZVVSSUNvbXBvbmVudCgpIGJ1dCBxdW90ZXMgZmV3ZXIgY2hhcmFjdGVycy5cbiAqXG4gKiBAc2VlIHJpc29uLnVyaV9va1xuICpcbiAqIGVuY29kZVVSSUNvbXBvbmVudCBwYXNzZXMgICB+ISooKS1fLidcbiAqIHJpc29uLnF1b3RlIGFsc28gcGFzc2VzICAgLDpAJC9cbiAqICAgYW5kIHF1b3RlcyBcIiBcIiBhcyBcIitcIiBpbnN0ZWFkIG9mIFwiJTIwXCJcbiAqL1xucmlzb24ucXVvdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKC9eWy1BLVphLXowLTl+ISooKV8uJyw6QCRcXC9dKiQvLnRlc3QoeCkpXG4gICAgICAgIHJldHVybiB4O1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh4KVxuICAgICAgICAucmVwbGFjZSgnJTJDJywgJywnLCAnZycpXG4gICAgICAgIC5yZXBsYWNlKCclM0EnLCAnOicsICdnJylcbiAgICAgICAgLnJlcGxhY2UoJyU0MCcsICdAJywgJ2cnKVxuICAgICAgICAucmVwbGFjZSgnJTI0JywgJyQnLCAnZycpXG4gICAgICAgIC5yZXBsYWNlKCclMkYnLCAnLycsICdnJylcbiAgICAgICAgLnJlcGxhY2UoJyUyMCcsICcrJywgJ2cnKTtcbn07XG5cblxuLy9cbi8vICBiYXNlZCBvbiBqc29uLmpzIDIwMDYtMDQtMjggZnJvbSBqc29uLm9yZ1xuLy8gIGxpY2Vuc2U6IGh0dHA6Ly93d3cuanNvbi5vcmcvbGljZW5zZS5odG1sXG4vL1xuLy8gIGhhY2tlZCBieSBuaXggZm9yIHVzZSBpbiB1cmlzLlxuLy9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3EgPSB7IC8vIHVybC1vayBidXQgcXVvdGVkIGluIHN0cmluZ3NcbiAgICAgICAgICAgICAgIFwiJ1wiOiB0cnVlLCAgJyEnOiB0cnVlXG4gICAgfSxcbiAgICBzID0ge1xuICAgICAgICAgICAgYXJyYXk6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbJyEoJ10sIGIsIGYsIGksIGwgPSB4Lmxlbmd0aCwgdjtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB4W2ldO1xuICAgICAgICAgICAgICAgICAgICBmID0gc1t0eXBlb2Ygdl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gZih2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbYS5sZW5ndGhdID0gJywnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2EubGVuZ3RoXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYVthLmxlbmd0aF0gPSAnKSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuam9pbignJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2Jvb2xlYW4nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmICh4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyF0JztcbiAgICAgICAgICAgICAgICByZXR1cm4gJyFmJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdudWxsJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIhblwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bWJlcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKHgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyFuJztcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCAnKycgb3V0IG9mIGV4cG9uZW50LCAnLScgaXMgb2sgdGhvdWdoXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh4KS5yZXBsYWNlKC9cXCsvLCcnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuYXJyYXkoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV0lMTDogd2lsbCB0aGlzIHdvcmsgb24gbm9uLUZpcmVmb3ggYnJvd3NlcnM/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeC5fX3Byb3RvdHlwZV9fID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgeC5fX3Byb3RvdHlwZV9fLmVuY29kZV9yaXNvbiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5lbmNvZGVfcmlzb24oKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFsnKCddLCBiLCBmLCBpLCB2LCBraSwga3M9W107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiB4KVxuICAgICAgICAgICAgICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGtzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChraSA9IDA7IGtpIDwga3MubGVuZ3RoOyBraSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0ga3Nba2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gc1t0eXBlb2Ygdl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBmKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVthLmxlbmd0aF0gPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHMuc3RyaW5nKGkpLCAnOicsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYVthLmxlbmd0aF0gPSAnKSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyFuJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHggPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIicnXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAocmlzb24uaWRfb2sudGVzdCh4KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG5cbiAgICAgICAgICAgICAgICB4ID0geC5yZXBsYWNlKC8oWychXSkvZywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3FbYl0pIHJldHVybiAnIScrYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJ1wiICsgeCArIFwiJ1wiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuZGVmaW5lZDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyaXNvbiBjYW4ndCBlbmNvZGUgdGhlIHVuZGVmaW5lZCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogcmlzb24tZW5jb2RlIGEgamF2YXNjcmlwdCBzdHJ1Y3R1cmVcbiAgICAgKlxuICAgICAqICBpbXBsZW1lbWVudGF0aW9uIGJhc2VkIG9uIERvdWdsYXMgQ3JvY2tmb3JkJ3MganNvbi5qczpcbiAgICAgKiAgICBodHRwOi8vanNvbi5vcmcvanNvbi5qcyBhcyBvZiAyMDA2LTA0LTI4IGZyb20ganNvbi5vcmdcbiAgICAgKlxuICAgICAqL1xuICAgIHJpc29uLmVuY29kZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBzW3R5cGVvZiB2XSh2KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmlzb24tZW5jb2RlIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aG91dCBzdXJyb3VuZGluZyBwYXJlbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHJpc29uLmVuY29kZV9vYmplY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodHlwZW9mIHYgIT0gJ29iamVjdCcgfHwgdiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyaXNvbi5lbmNvZGVfb2JqZWN0IGV4cGVjdHMgYW4gb2JqZWN0IGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgciA9IHNbdHlwZW9mIHZdKHYpO1xuICAgICAgICByZXR1cm4gci5zdWJzdHJpbmcoMSwgci5sZW5ndGgtMSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJpc29uLWVuY29kZSBhIGphdmFzY3JpcHQgYXJyYXkgd2l0aG91dCBzdXJyb3VuZGluZyBwYXJlbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHJpc29uLmVuY29kZV9hcnJheSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghKHYgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyaXNvbi5lbmNvZGVfYXJyYXkgZXhwZWN0cyBhbiBhcnJheSBhcmd1bWVudFwiKTtcbiAgICAgICAgdmFyIHIgPSBzW3R5cGVvZiB2XSh2KTtcbiAgICAgICAgcmV0dXJuIHIuc3Vic3RyaW5nKDIsIHIubGVuZ3RoLTEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByaXNvbi1lbmNvZGUgYW5kIHVyaS1lbmNvZGUgYSBqYXZhc2NyaXB0IHN0cnVjdHVyZVxuICAgICAqXG4gICAgICovXG4gICAgcmlzb24uZW5jb2RlX3VyaSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiByaXNvbi5xdW90ZShzW3R5cGVvZiB2XSh2KSk7XG4gICAgfTtcblxufSkoKTtcblxuXG5cblxuLy9cbi8vIGJhc2VkIG9uIG9wZW5sYXN6bG8tanNvbiBhbmQgaGFja2VkIGJ5IG5peCBmb3IgdXNlIGluIHVyaXMuXG4vL1xuLy8gQXV0aG9yOiBPbGl2ZXIgU3RlZWxlXG4vLyBDb3B5cmlnaHQ6IENvcHlyaWdodCAyMDA2IE9saXZlciBTdGVlbGUuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gSG9tZXBhZ2U6IGh0dHA6Ly9vc3RlZWxlLmNvbS9zb3VyY2VzL29wZW5sYXN6bG8vanNvblxuLy8gTGljZW5zZTogTUlUIExpY2Vuc2UuXG4vLyBWZXJzaW9uOiAxLjBcblxuXG4vKipcbiAqIHBhcnNlIGEgcmlzb24gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IHN0cnVjdHVyZS5cbiAqXG4gKiB0aGlzIGlzIHRoZSBzaW1wbGVzdCBkZWNvZGVyIGVudHJ5IHBvaW50LlxuICpcbiAqICBiYXNlZCBvbiBPbGl2ZXIgU3RlZWxlJ3MgT3Blbkxhc3psby1KU09OXG4gKiAgICAgaHR0cDovL29zdGVlbGUuY29tL3NvdXJjZXMvb3Blbmxhc3psby9qc29uXG4gKi9cbnJpc29uLmRlY29kZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgZXJyY2IgPSBmdW5jdGlvbihlKSB7IHRocm93IEVycm9yKCdyaXNvbiBkZWNvZGVyIGVycm9yOiAnICsgZSk7IH07XG4gICAgdmFyIHAgPSBuZXcgcmlzb24ucGFyc2VyKGVycmNiKTtcbiAgICByZXR1cm4gcC5wYXJzZShyKTtcbn07XG5cbi8qKlxuICogcGFyc2UgYW4gby1yaXNvbiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RydWN0dXJlLlxuICpcbiAqIHRoaXMgc2ltcGx5IGFkZHMgcGFyZW50aGVzZXMgYXJvdW5kIHRoZSBzdHJpbmcgYmVmb3JlIHBhcnNpbmcuXG4gKi9cbnJpc29uLmRlY29kZV9vYmplY3QgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHJpc29uLmRlY29kZSgnKCcrcisnKScpO1xufTtcblxuLyoqXG4gKiBwYXJzZSBhbiBhLXJpc29uIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJ1Y3R1cmUuXG4gKlxuICogdGhpcyBzaW1wbHkgYWRkcyBhcnJheSBtYXJrdXAgYXJvdW5kIHRoZSBzdHJpbmcgYmVmb3JlIHBhcnNpbmcuXG4gKi9cbnJpc29uLmRlY29kZV9hcnJheSA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gcmlzb24uZGVjb2RlKCchKCcrcisnKScpO1xufTtcblxuXG4vKipcbiAqIGNvbnN0cnVjdCBhIG5ldyBwYXJzZXIgb2JqZWN0IGZvciByZXVzZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBBIFJpc29uIHBhcnNlciBjbGFzcy4gIFlvdSBzaG91bGQgcHJvYmFibHkgXG4gKiAgICAgICAgdXNlIHJpc29uLmRlY29kZSBpbnN0ZWFkLiBcbiAqIEBzZWUgcmlzb24uZGVjb2RlXG4gKi9cbnJpc29uLnBhcnNlciA9IGZ1bmN0aW9uIChlcnJjYikge1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyY2I7XG59O1xuXG4vKipcbiAqIGEgc3RyaW5nIGNvbnRhaW5pbmcgYWNjZXB0YWJsZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gKiBieSBkZWZhdWx0IHRoZSByaXNvbiBkZWNvZGVyIHRvbGVyYXRlcyBubyB3aGl0ZXNwYWNlLlxuICogdG8gYWNjZXB0IHdoaXRlc3BhY2Ugc2V0IHJpc29uLnBhcnNlci5XSElURVNQQUNFID0gXCIgXFx0XFxuXFxyXFxmXCI7XG4gKi9cbnJpc29uLnBhcnNlci5XSElURVNQQUNFID0gXCJcIjtcblxuLy8gZXhwb3NlIHRoaXMgYXMtaXM/XG5yaXNvbi5wYXJzZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zWydlcnJvckhhbmRsZXInXSlcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBvcHRpb25zLmVycm9ySGFuZGxlcjtcbn07XG5cbi8qKlxuICogcGFyc2UgYSByaXNvbiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RydWN0dXJlLlxuICovXG5yaXNvbi5wYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5yZWFkVmFsdWUoKTtcbiAgICBpZiAoIXRoaXMubWVzc2FnZSAmJiB0aGlzLm5leHQoKSlcbiAgICAgICAgdmFsdWUgPSB0aGlzLmVycm9yKFwidW5hYmxlIHRvIHBhcnNlIHN0cmluZyBhcyByaXNvbjogJ1wiICsgcmlzb24uZW5jb2RlKHN0cikgKyBcIidcIik7XG4gICAgaWYgKHRoaXMubWVzc2FnZSAmJiB0aGlzLmVycm9ySGFuZGxlcilcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIodGhpcy5tZXNzYWdlLCB0aGlzLmluZGV4KTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5yaXNvbi5wYXJzZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mKGNvbnNvbGUpICE9ICd1bmRlZmluZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygncmlzb24gcGFyc2VyIGVycm9yOiAnLCBtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4gICAgXG5yaXNvbi5wYXJzZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYyA9IHRoaXMubmV4dCgpO1xuICAgIHZhciBmbiA9IGMgJiYgdGhpcy50YWJsZVtjXTtcblxuICAgIGlmIChmbilcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMpO1xuXG4gICAgLy8gZmVsbCB0aHJvdWdoIHRhYmxlLCBwYXJzZSBhcyBhbiBpZFxuXG4gICAgdmFyIHMgPSB0aGlzLnN0cmluZztcbiAgICB2YXIgaSA9IHRoaXMuaW5kZXgtMTtcblxuICAgIC8vIFJlZ2V4cC5sYXN0SW5kZXggbWF5IG5vdCB3b3JrIHJpZ2h0IGluIElFIGJlZm9yZSA1LjU/XG4gICAgLy8gZyBmbGFnIG9uIHRoZSByZWdleHAgaXMgYWxzbyBuZWNlc3NhcnlcbiAgICByaXNvbi5uZXh0X2lkLmxhc3RJbmRleCA9IGk7XG4gICAgdmFyIG0gPSByaXNvbi5uZXh0X2lkLmV4ZWMocyk7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnbWF0Y2hlZCBpZCcsIGksIHIubGFzdEluZGV4KTtcblxuICAgIGlmIChtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGlkID0gbVswXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGkraWQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gaWQ7ICAvLyBhIHN0cmluZ1xuICAgIH1cblxuICAgIGlmIChjKSByZXR1cm4gdGhpcy5lcnJvcihcImludmFsaWQgY2hhcmFjdGVyOiAnXCIgKyBjICsgXCInXCIpO1xuICAgIHJldHVybiB0aGlzLmVycm9yKFwiZW1wdHkgZXhwcmVzc2lvblwiKTtcbn1cblxucmlzb24ucGFyc2VyLnBhcnNlX2FycmF5ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIHZhciBhciA9IFtdO1xuICAgIHZhciBjO1xuICAgIHdoaWxlICgoYyA9IHBhcnNlci5uZXh0KCkpICE9ICcpJykge1xuICAgICAgICBpZiAoIWMpIHJldHVybiBwYXJzZXIuZXJyb3IoXCJ1bm1hdGNoZWQgJyEoJ1wiKTtcbiAgICAgICAgaWYgKGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGMgIT0gJywnKVxuICAgICAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIm1pc3NpbmcgJywnXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT0gJywnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmVycm9yKFwiZXh0cmEgJywnXCIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIC0tcGFyc2VyLmluZGV4O1xuICAgICAgICB2YXIgbiA9IHBhcnNlci5yZWFkVmFsdWUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09IFwidW5kZWZpbmVkXCIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGFyLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5cbnJpc29uLnBhcnNlci5iYW5ncyA9IHtcbiAgICB0OiB0cnVlLFxuICAgIGY6IGZhbHNlLFxuICAgIG46IG51bGwsXG4gICAgJygnOiByaXNvbi5wYXJzZXIucGFyc2VfYXJyYXlcbn1cblxucmlzb24ucGFyc2VyLnByb3RvdHlwZS50YWJsZSA9IHtcbiAgICAnISc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnN0cmluZztcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgICBpZiAoIWMpIHJldHVybiB0aGlzLmVycm9yKCdcIiFcIiBhdCBlbmQgb2YgaW5wdXQnKTtcbiAgICAgICAgdmFyIHggPSByaXNvbi5wYXJzZXIuYmFuZ3NbY107XG4gICAgICAgIGlmICh0eXBlb2YoeCkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHguY2FsbChudWxsLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoeCkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCd1bmtub3duIGxpdGVyYWw6IFwiIScgKyBjICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICAnKCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHdoaWxlICgoYyA9IHRoaXMubmV4dCgpKSAhPSAnKScpIHtcbiAgICAgICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChjICE9ICcsJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIm1pc3NpbmcgJywnXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09ICcsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiZXh0cmEgJywnXCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgLS10aGlzLmluZGV4O1xuICAgICAgICAgICAgdmFyIGsgPSB0aGlzLnJlYWRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09IFwidW5kZWZpbmVkXCIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KCkgIT0gJzonKSByZXR1cm4gdGhpcy5lcnJvcihcIm1pc3NpbmcgJzonXCIpO1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnJlYWRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09IFwidW5kZWZpbmVkXCIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvW2tdID0gdjtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfSxcbiAgICBcIidcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3RyaW5nO1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBzdGFydCA9IGk7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKChjID0gcy5jaGFyQXQoaSsrKSkgIT0gXCInXCIpIHtcbiAgICAgICAgICAgIC8vaWYgKGkgPT0gcy5sZW5ndGgpIHJldHVybiB0aGlzLmVycm9yKCd1bm1hdGNoZWQgXCJcXCdcIicpO1xuICAgICAgICAgICAgaWYgKCFjKSByZXR1cm4gdGhpcy5lcnJvcigndW5tYXRjaGVkIFwiXFwnXCInKTtcbiAgICAgICAgICAgIGlmIChjID09ICchJykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IGktMSlcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzLnNsaWNlKHN0YXJ0LCBpLTEpKTtcbiAgICAgICAgICAgICAgICBjID0gcy5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBpZiAoXCIhJ1wiLmluZGV4T2YoYykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdpbnZhbGlkIHN0cmluZyBlc2NhcGU6IFwiIScrYysnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IGktMSlcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gocy5zbGljZShzdGFydCwgaS0xKSk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID09IDEgPyBzZWdtZW50c1swXSA6IHNlZ21lbnRzLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLy8gQWxzbyBhbnkgZGlnaXQuICBUaGUgc3RhdGVtZW50IHRoYXQgZm9sbG93cyB0aGlzIHRhYmxlXG4gICAgLy8gZGVmaW5pdGlvbiBmaWxscyBpbiB0aGUgZGlnaXRzLlxuICAgICctJzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3RyaW5nO1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBzdGFydCA9IGktMTtcbiAgICAgICAgdmFyIHN0YXRlID0gJ2ludCc7XG4gICAgICAgIHZhciBwZXJtaXR0ZWRTaWducyA9ICctJztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25zID0ge1xuICAgICAgICAgICAgJ2ludCsuJzogJ2ZyYWMnLFxuICAgICAgICAgICAgJ2ludCtlJzogJ2V4cCcsXG4gICAgICAgICAgICAnZnJhYytlJzogJ2V4cCdcbiAgICAgICAgfTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGMgPSBzLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgaWYgKCFjKSBicmVhaztcbiAgICAgICAgICAgIGlmICgnMCcgPD0gYyAmJiBjIDw9ICc5JykgY29udGludWU7XG4gICAgICAgICAgICBpZiAocGVybWl0dGVkU2lnbnMuaW5kZXhPZihjKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVybWl0dGVkU2lnbnMgPSAnJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gdHJhbnNpdGlvbnNbc3RhdGUrJysnK2MudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT0gJ2V4cCcpIHBlcm1pdHRlZFNpZ25zID0gJy0nO1xuICAgICAgICB9IHdoaWxlIChzdGF0ZSk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtLWk7XG4gICAgICAgIHMgPSBzLnNsaWNlKHN0YXJ0LCBpKVxuICAgICAgICBpZiAocyA9PSAnLScpIHJldHVybiB0aGlzLmVycm9yKFwiaW52YWxpZCBudW1iZXJcIik7XG4gICAgICAgIHJldHVybiBOdW1iZXIocyk7XG4gICAgfVxufTtcbi8vIGNvcHkgdGFibGVbJy0nXSB0byBlYWNoIG9mIHRhYmxlW2ldIHwgaSA8LSAnMCcuLic5JzpcbihmdW5jdGlvbiAodGFibGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA5OyBpKyspXG4gICAgICAgIHRhYmxlW1N0cmluZyhpKV0gPSB0YWJsZVsnLSddO1xufSkocmlzb24ucGFyc2VyLnByb3RvdHlwZS50YWJsZSk7XG5cbi8vIHJldHVybiB0aGUgbmV4dCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIsIG9yIHVuZGVmaW5lZFxucmlzb24ucGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zdHJpbmc7XG4gICAgdmFyIGkgPSB0aGlzLmluZGV4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGkgPT0gcy5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQXQoaSsrKTtcbiAgICB9IHdoaWxlIChyaXNvbi5wYXJzZXIuV0hJVEVTUEFDRS5pbmRleE9mKGMpID49IDApO1xuICAgIHRoaXMuaW5kZXggPSBpO1xuICAgIHJldHVybiBjO1xufTtcblxuLy8gRW5kIG9mIFVNRCBtb2R1bGUgd3JhcHBlclxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/rison/js/rison.js\n");

/***/ })

}]);